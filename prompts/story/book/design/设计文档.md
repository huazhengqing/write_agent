# 动态层级分解模型

## 核心理念与目标
### 核心理念
动态规划, 迭代创作。摒弃一次性的静态大纲, 采用"规划 -> 判断 -> (执行 | 分解)"的持续循环。系统在每一步都进行自我评估和调整, 模拟人类创作者在写作中不断思考和修正的过程, 以激发创造力并保证过程稳定。
### 核心目标
- 提升质量上限: 通过引入批判性思维和动态调整, 创造具有独创性的内容。
- 聚焦核心任务: 每轮规划只生成少数关键任务, 避免资源浪费。
- 实现动态纠错: 执行后即时判断, 允许系统根据中间结果调整后续路径。
### 核心优势
- 高创造力: "辩论"机制与动态纠错, 激发创意。
- 流程稳定: 规则驱动的智能体确保过程可控。
- 专业化分工: 按叙事层级调用不同专家, 提升各阶段规划质量。
- 成本效益高: 即时分解策略聚焦于当前任务, 避免了对未确定性的未来投入过多沉没成本。
### 流程控制原则
- 技术实现: 项目采用 `prefect` 作为流程控制框架。
- 顺序执行: 为保证最高创作质量, 系统在处理单本书的创作流程时, 严格遵循深度优先的顺序执行模式, 杜绝任何形式的并行处理。这模拟了人类顶级专家在创作时专注、线性的思考过程。
- 无并行: 系统不允许对一本书的内部任务(如同时设计世界观和角色)进行并行处理。流程控制完全由代码逻辑驱动, 不依赖外部状态机或图数据库进行调度。
- 宏观并行: 系统的并行能力体现在可以同时启动多个独立的、完整的书籍创作流程, 但每个流程内部依然是严格串行的。


## 核心概念
### 任务类型
整个创作过程被分解为三种基础任务: 
- 设计 (Design): 规划故事的蓝图。负责世界观、情节大纲、人物设定等所有非正文的创意工作。
- 写作 (Write): 填充故事的血肉。负责产出小说正文。
- 搜索 (Search): 收集创作的素材。负责信息收集、背景研究等。
### 设计先行原则
先规划"如何设计", 再执行"设计"。在进行任何实质性设计(如构思情节)之前, 系统会先生成一个"设计任务清单"(To-Do List)。这个清单明确了要完成当前创作单元(如一章), 需要从哪些维度(如核心冲突、角色动机、场景氛围)进行思考, 确保设计的完备性。


## 模型架构: 核心智能体
- 规划智能体 (Planning Agent Group): 战略规划师。负责将一个高阶任务(如"规划第一卷")分解为一系列具体的 `design` 或 `search` 子任务。该智能体组内部包含多个角色(如提议者、批判者), 通过辩论协作产出高质量的规划。
    - 分级调用: 根据叙事层级(全书、卷、章等)调用不同版本的专家, 确保规划的深度与效率相匹配。
- 叙事层级结构划分智能体 (Hierarchy Division Agent): 结构工程师。当一个 `write` 任务因篇幅过大(如"写一本书")需要分解时, 此智能体负责将其沿叙事层级(书 -> 卷 -> 幕 -> 章)分解为下一层级的 `write` 子任务。
- 流程决策智能体 (Flow Decision Agent): 项目总监。在一个创作单元(如一卷)的设计阶段完成后, 此智能体负责审查所有设计成果, 并做出关键决策: 
    1.  `继续规划`: 设计尚不完备, 需补充设计任务。
    2.  `层级划分`: 设计已完备但篇幅过大, 需调用叙事层级结构划分智能体。
    3.  `开始写作`: 设计完备且篇幅合适, 启动写作流程。
- 原子判断智能体 (Atom Judger Agent): 任务分拣员。判断一个任务是需要进一步分解的"复杂任务", 还是可以立即执行的"原子任务"。它的判断会参考上游任务附带的`complexity_score`元数据, 以提高准确性。
- 分解智能体 (Decomposition Agent): 任务拆解师。当一个 `design` 或 `search` 任务被判定为"复杂任务"时, 此智能体负责将其分解为一系列粒度更细、目标更聚焦的子任务。它不进行创造性规划, 而是对现有任务进行结构化拆解。
- 执行智能体 (Execution Agents): 一线执行者。负责执行各类"原子任务"。
    - Design Executor: 执行具体的设计任务。
    - Write Executor: 执行具体的写作任务。
    - Search Executor: 执行具体的搜索任务。


## 核心工作流程: 以示例贯穿
整个系统的核心是"规划 -> 判断 -> (执行 | 分解)"的动态循环。为了清晰地展示其运作方式, 我们以一个从零开始创作一部50万字小说《星辰之子》的完整流程为例。
- 熔断机制 (Circuit Breaker): 为了防止因追求完美而陷入无限规划, 系统流程控制器内置了"最大规划轮次"的熔断机制。当在同一叙事层级(如"全书"或"卷")的规划循环达到预设次数(例如3次)后, 即使`流程决策智能体`仍然认为设计不完备, 流程控制器也会强制中断循环, 并根据当前任务状态(如目标篇幅)推进到下一阶段(`层级划分`或`开始写作`)。所有"待完善的设计点"将被记录, 并作为高优先级输入传递给下一层级的规划任务, 实现"带着问题前进"。此熔断机制由外部代码逻辑实现, 无需AI介入。

### 阶段一: 顶层规划 (全书级别)
1. 初始任务
系统接收到根任务: `Write Book: "星辰之子"`, 目标50万字。
2. 迭代式设计 (Iterative Design)
由于这是一个全新的项目, 没有任何设计方案, 系统首先需要进行顶层设计。
- 第1轮规划 (Planning):
    - 触发: 系统检测到`Write Book`任务缺少设计方案。
    - 行动: 调用全书级`规划智能体`。
    - 产出: 生成第一批最高优先级的`design`任务, 例如: `design [全书核心世界观与力量体系]`。
- 任务处理循环 (Task Processing Loop):
    - 判断 (Atom Judge): `原子判断智能体`分析任务`design [全书核心世界观与力量体系]`, 因其范围过大, 判定为`complex`。
    - 分解 (Decompose): `分解智能体`被调用, 将该复杂任务拆解为更具体的子任务: 
        - `design [世界观的核心概念与历史背景]`
        - `design [主要力量体系的等级、表现与限制]`
    - 执行 (Execute): 系统递归处理这些子任务。假设它们被判定为`atom`, `设计执行智能体`将逐一完成它们, 产出具体的设计文档。
- 第2轮规划 (Flow Decision & Continue Planning):
    - 触发: 第一批设计任务(世界观、力量体系)已全部完成。
    - 行动: 全书级`流程决策智能体`被调用, 审查当前已有的设计成果。
    - 决策: 它发现设计尚不完备(缺少核心情节、角色弧光等), 因此输出决策: `DECISION_CONTINUE_PLANNING`。
    - 再次规划: 系统返回第1轮规划的步骤, 全书级`规划智能体`再次被调用, 根据已有的世界观设计, 生成新一批`design`任务, 如: `design [主角的核心成长弧光]` 和 `design [全书主线情节骨架]`。
- 完成设计: 系统重复"规划 -> 处理 -> 决策"的循环, 直到`流程决策智能体`认为全书的顶层设计已足够完备。

### 阶段二: 层级划分 (从"书"到"卷")
1. 触发层级划分
- 触发: 全书所有顶层设计任务均已完成。
- 行动: 全书级`流程决策智能体`再次被调用。
- 决策: 这一次, 它判定设计已完备。但它检查到`Write Book`任务的目标字数(50万字)远超单次写作的合理阈值, 因此输出最终决策: `DECISION_DIVIDE_HIERARCHY`。
2. 执行层级划分
- 行动: `叙事层级结构划分智能体`被调用。
- 上下文: 它接收到完整的`全书设计方案`作为指导。
- 策略: 采用"即时/增量分解"策略。
- 产出: 它将`Write Book`任务分解为第一个子任务: `Write Volume 1: "帝国的阴影"`, 并根据全书大纲为其分配好核心使命(如"主角觉醒并逃离故乡")和预估字数(如15万字)。
    - 注意: `Write Volume 2`等后续任务此时并不会被创建, 以聚焦当前、节约成本。

### 阶段三: 进入下一叙事层级循环 (卷级别)
1. 新的循环开始
一个新的、更具体的任务`Write Volume 1`诞生了。现在, 整个核心工作流程在这个"卷"的层级上完整地重新开始: 
- 迭代式设计: 系统将调用卷级`规划智能体`, 为"第一卷"生成更详细的设计任务(如`design [第一卷反派配角]`、`design [第一卷关键转折事件]`), 并通过"判断->分解/执行->决策"的循环, 直至"第一卷"的设计全部完成。
- 叙事层级划分: 当"第一卷"设计完成后, 卷级`流程决策智能体`会发现其15万字的目标篇幅依然过大, 再次做出`DECISION_DIVIDE_HIERARCHY`决策。
- 再次分解: `叙事层级结构划分智能体`被调用, 将`Write Volume 1`分解为`Write Act 1`。
2. 递归直至原子任务
这个"设计 -> 划分"的过程会沿着`书 -> 卷 -> 幕 -> 章`的叙事层级不断递归。

### 阶段四: 执行写作
1. 触发写作
- 触发: 经过多层分解, 系统最终得到了一个任务, 例如`Write Chapter 1`, 目标字数3000字。
- 行动: 章级`流程决策智能体`在完成该章节所有`design`任务后, 判定设计完备且篇幅合适。
- 决策: 输出决策: `DECISION_PROCEED_TO_WRITE`。
2. 执行写作流程
- 行动: `写作执行智能体`被调用, 启动其内部的"规划-草稿-批判-精炼-摘要-审查"的标准化流程, 最终产出"第一章"的完整正文和摘要。

### 阶段五: 完成与推进
1. 单元完成
当`Write Chapter 1`任务完成后, 控制权返回其父任务`Write Act 1`。
2. 增量生成新任务
系统会再次调用`叙事层级结构划分智能体`, 此时它会接收到"第一章已完成"的上下文, 并基于此生成下一个任务`Write Chapter 2`。
3. 最终完成
这个过程将持续进行, 直到最初的根任务`Write Book: "星辰之子"`下的所有子任务全部完成, 整部小说创作结束。


## 智能体设计: 规划智能体: 辩论驱动的原则式规划
- 此智能体组通过"辩论驱动"的工作流, 取代静态清单, 生成动态且高质量的规划任务。它根据叙事层级的不同, 调用不同复杂度的流程和专家提示词。
- 所有规划流程的最终产出均为一个直接符合Pydantic模型的、机器可解析的JSON任务列表。这通过在流程的最后一步(通常是`精炼者`)利用LLM的`JSON Mode`或`Function Calling`能力实现, 移除了独立的格式化步骤, 提升了稳定性和效率。
### 分级规划策略: 平衡创造力与效率
- 根据不同叙事层级的创作任务特性(战略重要性 vs. 执行效率), 我们采用分级的规划策略, 以在保证质量的同时平衡成本。
### 策略总览
| 叙事层级 | 核心任务 | 规划流程 | 流程说明 | 提示词路径 |
| :--- | :--- | :--- | :--- | :--- |
| 全书、卷、幕 | 战略与结构设计 | 3步: 提议 -> 批判 -> 精炼 | 最大化创意与战略深度, 保证顶层设计质量。 | `.../{book,volume,act}/plan/...` |
| 章、场景 | 情节执行与细化 | 2步: 规划 -> 精炼 | 在已有框架内高效组织情节, 侧重逻辑与连贯。 | `.../{chapter,scene}/plan/...` |
| 节拍、段落 | 细节动作与描写 | 1步: 直接规划 | 任务目标明确, 以最高效率直接生成设计方案。 | `.../{beat,paragraph}/plan/...` |
### 动态专家调用: 基于篇幅的自适应策略
- 对于"全书"这一最高战略叙事层级, 其规划的深度和广度直接决定了整个故事的上限。一部20万字的中篇小说和一部500万字的超长篇史诗, 其顶层设计的要求截然不同。为了应对这一挑战, 系统引入了基于目标篇幅的动态专家调用机制。
- 策略说明: 在处理"全书"级别的规划任务时, 系统会首先检查任务的`目标字数`, 并根据预设的阈值, 调用不同版本的"专家"提示词(如`proposer`、`critic`等)。这些专家版本在核心任务上保持一致, 但在规划的侧重点、深度和广度上存在显著差异。
#### 专家版本与篇幅阈值
| 目标篇幅 | 适用类型 | 专家版本 (示例) | 核心规划侧重点 |
| :--- | :--- | :--- | :--- |
| < 20万字 | 短篇 | `proposer_short.py` | 核心情节驱动: 聚焦于单一、紧凑的主线情节和核心角色弧光。 |
| 20万 - 100万字 | 中篇 | `proposer_medium.py` | 结构与生态: 除了主线, 必须设计关键的B故事线、更丰富的角色生态, 以及明确的全书多阶段(如三到五幕)结构。 |
| > 100万字 | 长篇 | `proposer_long.py` | 体系与可扩展性: 规划重心转向设计可持续演进的核心体系(如力量、经济、社会), 并为世界观预留足够的扩展接口, 确保后期内容不乏力。 |
#### 实现示例
假设系统接到一个目标为200万字的"全书"规划任务: 
1.  触发: 系统在启动3步规划流程前, 检测到目标字数 > 100万字。
2.  专家选择: 系统决定调用`long`版本的专家组。
3.  调用提议者: 系统将调用 `prompts/story/plan/book/proposer_long.py`。
    - 该提示词的`#原则`部分会明确要求: "体系优先原则: 你的首要任务不是构思具体情节, 而是设计能够支撑200万字内容、可持续迭代的核心体系, 例如力量成长体系的完整等级规划、世界观中不同文明的冲突与演化规则等。" `prompts/story/book/plan/proposer_long.py`。
4.  调用批判者: 相应地, `prompts/story/book/plan/critic_long.py` 会被调用。
    - 其`#批判原则`会包含: "可扩展性质询: 提议的力量体系天花板是否足够高?后期是否会因数值膨胀而崩溃?世界观设定是否预留了引入新地图、新种族的接口?" `prompts/story/book/plan/critic_long.py`。
5.  调用精炼者: `prompts/story/book/plan/refiner.py` 最终生成的规划任务, 将包含大量关于"体系设计"的`design`任务, 而不仅仅是"情节设计"任务。 `prompts/story/book/plan/refiner.py`。
通过这种方式, 系统确保了对不同规模的项目, 从一开始就采用与之匹配的战略规划深度, 为后续的成功奠定了坚实基础。

### 3步规划流程详解 (提议-批判-精炼)
适用层级: `全书`、`卷`、`幕` (高战略层级)
#### 第一步: 提议者 (Proposer) - 起草完整规划方案
#### 第二步: 批判者 (Critic) - 压力测试, 注入深度
#### 第三步: 精炼者 (Refiner) - 提炼共识, 生成最终JSON任务
- 任务: 综合双方意见, 在内部形成最终的规划方案, 然后直接调用LLM的`JSON Mode`或`Function Calling`功能, 生成一个符合`PlanOutput`模型的、最终的JSON任务对象。

### 2步规划流程详解 (规划-精炼)
适用叙事层级: `章`、`场景` (情节执行层级)
#### 第一步: 规划者 (Planner) - 起草规划方案
- 角色: 任务规划专家。
- 原则: 
    - 功能承接原则: 规划的任务必须服务于上层设计的核心目标。
    - 结构完整性原则: 规划的子任务应能构成一个逻辑自洽、体验完整的情节单元。
#### 第二步: 精炼者 (Refiner) - 审查并生成最终JSON
- 角色: 理性的结构编辑。
- 原则: 
    - 审查优化: 检查规划草案的逻辑连贯性、任务明确性, 并进行优化和修订。
    - 精确翻译与格式至上: 在内部完成优化后, 严格按照最终方案, 直接生成符合`PlanOutput` Pydantic模型的JSON对象。
    - 零创造性: 在生成JSON时, 不添加任何额外逻辑。
- 任务: 审查并精炼规划草案, 然后直接调用LLM的`JSON Mode`或`Function Calling`功能, 生成一个符合`PlanOutput`模型的、最终的JSON任务对象。

### 1步规划流程详解 (直接规划)
适用叙事层级: `节拍`、`段落` (微观执行层级)
#### 直接规划器 (Direct Planner)
- 角色: 微观任务规划专家。
- 原则:
    - 功能导向: 规划必须服务于一个明确的微观叙事功能(推进动作、揭示信息、渲染情绪)。
    - 一步到位: 直接生成最终的、结构化的规划草案, 无需后续审查。
    - 格式至上: 直接输出符合`PlanOutput` Pydantic模型的JSON对象。
- 任务: 基于原则, 将微观任务目标直接转化为一个符合`PlanOutput`模型的、最终的JSON任务对象。


## 智能体设计: 流程决策智能体 (Flow Decision Agent) 
- 例如: `prompts/story/book/flow_decision/flow_decision.py`
- 基于所有输入信息, 判断当前的全书设计是否足以支撑后续创作, 并输出一个明确的流程决策。


## 智能体设计: 叙事层级结构划分智能体 (Hierarchy Division Agent)
### 总体设计
- 角色: 叙事结构工程师, 负责将一个宏大的写作单元(如"书")分解为下一个层级的、可管理的写作子单元(如"卷")。
- 触发: 当`流程决策智能体`输出`DECISION_DIVIDE_HIERARCHY`时被调用。
- 分级专家: 该智能体根据当前任务的层级, 调用不同版本的专家。
    - 示例: 当分解"书"为"卷"时, 系统会调用 `prompts/story/book/hierarchy/` 目录下的专家组。
- 核心策略: 采用分级工作流与分级分解策略, 根据任务层级动态调整规划的深度和粒度, 以平衡规划质量与效率。
### 分级工作流详解
#### 策略总览
| 分解叙事层级 (输入 -> 输出) | 战略重要性 | 工作流复杂度 | 分解策略 | 提示词路径 |
| :--- | :--- | :--- | :--- | :--- |
| 书 -> 卷 | 最高 | 3步: Proposer -> Critic -> Refiner | **质量优先分解**: 根据战略需要, 生成一个或多个高质量的单元。数量由AI决定, 重点是确保每个单元的规划都足够详细和深入。 | `.../book/hierarchy/...` |
| 卷 -> 幕 | 高 | 3步: Proposer -> Critic -> Refiner | **质量优先分解**: 根据战略需要, 生成一个或多个高质量的单元。数量由AI决定, 重点是确保每个单元的规划都足够详细和深入。 | `.../volume/hierarchy/...` |
| 幕 -> 章 | 中 | 2步: Planner -> Refiner | **质量优先分解**: 根据上层设计, 生成一个或多个逻辑连贯的单元。数量由AI决定, 重点是确保情节映射完整、节奏合理。 | `.../act/hierarchy/...` |
| 章 -> 场景 | 中 | 2步: Planner -> Refiner | **完整分解**: 一次性生成当前章节下的所有场景, 确保章节结构的完整性。 | `.../chapter/hierarchy/...` |
| 场景 -> 节拍 | 低 | 1步: Direct Planner | **完整分解**: 一次性生成当前场景下的所有节拍, 确保事件流程的完整性。 | `.../scene/hierarchy/...` |
| 节拍 -> 段落 | 最低 | 1步: Direct Planner | **完整分解**: 一次性生成当前节拍下的所有段落, 确保动作和描写的完整性。 | `.../beat/hierarchy/...` |

#### 3步工作流详解 (Proposer -> Critic -> Refiner)
- 适用叙事层级: `书 -> 卷`, `卷 -> 幕`
- 流程说明: 这是最具战略性的划分, 需要通过辩论确保顶层结构的合理性与创造性。
##### 第一步: 提议者 (Proposer)
##### 第二步: 批判者 (Critic)
##### 第三步: 精炼者 (Refiner) - 生成最终JSON任务


#### 2步工作流详解 (Planner -> Refiner)
- 适用叙事层级: `幕 -> 章`, `章 -> 场景`
- 流程说明: 在已有明确框架(如幕/章的设计方案)下, 此流程旨在高效地将情节要点映射和组织到下一层级。
##### 第一步: 规划者 (Planner) (例如: `.../act/planner.py`)
- 角色: 结构规划师, 负责将一个叙事单元(如"幕"或"章")精确分解为一系列子单元(如"章"或"场景")。 (例如: `.../act/hierarchy/planner.py`)
- 任务: 直接根据上层设计方案, 起草一份完整的、结构化的下一叙事层级结构划分方案。
- 输入:
    - 上下文模板:
        - 高优先级: `上层设计方案`
        - 次优先级: `父任务`
    - 父任务: 当前需要被分解的`write`任务(例如, `Write Act 1`)。
    - 上层设计方案: 父任务对应的设计方案(例如, `第一幕设计方案`)。
- 原则:
    - 完整映射: 确保上层设计中的所有关键情节要点, 都被完整地映射到下一层级的子单元中。
    - 分级分解: 遵循`6.3.1`中定义的中观增量分解或微观完整分解策略。
- 输出: 一份仅包含所有子单元(如所有章)及其核心使命、字数分配、关键事件的Markdown规划草案。
##### 第二步: 精炼者 (Refiner) - 生成最终JSON任务 (例如: `.../act/hierarchy/refiner.py`)
- 角色: 结构编辑, 负责审查和最终确认结构划分方案。
- 任务: 审查规划草案的逻辑连贯性、节奏合理性, 进行最终优化, 并直接生成符合`PlanOutput`模型的JSON任务对象。
- 输入:
    - 上下文模板:
        - 高优先级: `规划者的Markdown规划草案`
        - 次优先级: `上层设计方案`
    - 规划者的Markdown规划草案。
    - 与规划者相同的上层设计方案。
- 原则:
    - 节奏优化: 检查子单元的排列组合是否形成了有效的情感曲线和叙事节奏。
    - 逻辑校验: 确保子单元之间的衔接流畅、逻辑自洽。
    - 格式至上: 直接输出符合`PlanOutput` Pydantic模型的JSON对象。
- 输出: 一个直接可用的`PlanOutput`模型的JSON对象, 其中`sub_tasks`列表包含对下一层级所有子单元的详细规划。
- 示例 (为"第一章"完整分解"场景"时, 直接输出JSON): 一个包含`reasoning`字段和`sub_tasks`列表的纯JSON对象。

#### 1步工作流详解 (Direct Planner)
- 适用叙事层级: `场景 -> 节拍`, `节拍 -> 段落`
- 流程说明: 这是最微观的划分, 任务目标明确, 旨在以最高效率完成。
##### 直接规划器 (Direct Planner) (例如: `.../scene/planner.py`)
- 角色: 微观结构规划师, 负责将一个具体的事件(如"场景")完整分解为一系列动作单元(如"节拍")。 (例如: `.../scene/hierarchy/planner.py`)
- 任务: 基于上层设计, 直接生成一份最终的、结构化的下一叙事层级结构划分方案。
- 输入:
    - 上下文模板: 
        - 高优先级: `上层设计方案`
        - 次优先级: `父任务`
    - 父任务: 当前需要被分解的`write`任务(例如, `Write Scene A`)。
    - 上层设计方案: 父任务对应的设计方案(例如, `场景A的设计方案`)。
- 原则:
    - 功能导向: 每个子单元(如节拍)都必须服务于一个明确的微观叙事功能(如推进动作、揭示信息、渲染情绪)。
    - 一步到位: 直接生成最终的、结构化的规划草案, 无需后续审查。
    - 格式至上: 直接输出符合`PlanOutput` Pydantic模型的JSON对象。
- 输出: 一个直接可用的`PlanOutput`模型的JSON对象, 其中`sub_tasks`列表包含对所有子单元(如所有节拍)的完整规划。
- 示例 (为"场景1"完整分解"节拍"时, 直接输出JSON): 一个包含`reasoning`字段和`sub_tasks`列表的纯JSON对象。


## 智能体设计: 分解智能体 (Decomposition Agent)
- 角色: 任务拆解师, 负责将一个定义模糊或范围过大的`design`或`search`任务, 进行结构化拆解。
- 触发: 当`原子判断智能体`将一个任务判定为`complex`时被调用。
- 核心区别: 与`规划智能体`不同, 分解智能体不进行从零开始的创造性规划, 而是对一个已存在的、目标明确但执行路径不清晰的任务进行逻辑分解。
- 分解策略: 采用一次性完整分解策略, 即一次性生成当前复杂任务所需的所有子任务, 确保分解的完备性。


## 智能体设计: 设计任务分解 (3步流程)
- 目标: 将一个宏大的设计任务(如"设计主角")分解为一系列具体的、可执行的设计子任务(如"设计主角背景"、"设计主角性格"、"设计主角能力")。
- 工作流: 采用通用的"提议-批判-精炼"三步流程, 确保分解的完备性与逻辑性。
- 提示词路径: `prompts/story/{level}/decomposition/design/{proposer, critic, refiner}.py`
#### 第一步: 提议者 (Proposer)
#### 第二步: 批判者 (Critic)
- 角色: 结构审查员。
- 任务: 审查提议的子任务清单, 检查其是否完备(有无遗漏关键维度)、是否正交(子任务间有无重叠)、粒度是否合适。
- 原则:
    - 完备性质询: "这个清单是否遗漏了对目标至关重要的方面?例如, 设计角色时是否考虑了他的社会关系?"
    - 正交性质询: "‘设计角色能力’和‘设计角色战斗风格’这两个任务是否有重叠?能否合并或重新定义边界?"
    - 粒度质询: "‘设计角色背景’这个任务是否仍然过大?是否应进一步分解为‘童年经历’和‘关键转折事件’?"
#### 第三步: 精炼者 (Refiner)

## 智能体设计: 搜索任务分解 (2步流程)
- Agent模式: 此流程中的`规划者`和`精炼者`适合采用 `ReAct Agent` 模式。它们可能需要通过主动查询来探索更广泛的关键词、验证信息源的可靠性, 或根据初步搜索结果调整后续的查询策略, 以确保分解出的搜索任务既全面又高效。
- 适用任务: 所有被判定为`complex`的`search`任务。
- 分析: 搜索任务的分解逻辑相对简单, 其核心是将一个模糊的搜索意图, 转化为一系列具体、可执行的搜索查询。一个"规划-精炼"的2步流程足以保证质量和效率。1步流程虽然更快, 但可能因缺乏审查而导致查询质量不高或方向偏颇。
- 目标: 将一个宽泛的研究任务(如"研究赛博朋克文化")分解为多个精确的搜索子任务(如"搜索赛博朋克的核心美学元素"、"搜索赛博朋克题材的经典作品列表"、"搜索义体改造在现实中的技术原型")。
- 工作流: 采用"规划-精炼"两步流程。
- 提示词路径: `prompts/story/{level}/decomposition/search/{planner, refiner}.py`
### 第一步: 规划者 (Planner)
- 角色: 信息架构师。
- 任务: 分析输入的复杂`search`任务, 将其分解为多个不同角度、不同关键词的子查询草案。
- 原则:
    - 查询多样性: 从不同角度设计查询(如事实型、背景型、动机型)。
    - 关键词精确性: 思考并使用更精确的关键词组合。
### 第二步: 精炼者 (Refiner)
- 角色: 查询优化师。
- 任务: 审查规划者提出的子任务清单, 优化查询语句, 合并相似查询, 确保每个子任务的目标都足够聚焦, 并直接生成最终的JSON任务对象。
- 原则:
    - 目标聚焦: "这个查询是否能得到一个明确的答案, 还是会返回一堆泛泛的信息?"
    - 效率优先: "这三个查询是否可以合并为一个更高效的查询?"

## 规划和分解的最终输出: Pydantic模型 PlanNode 结构
- 在提示词中增加以下内容: 
---
# JSON 字段
- `reasoning`: 思考过程。
- `id`: 父任务ID.子任务序号。根任务为"1"。
- `task_type`: 'design', 'search', 或 'write'。
- `hierarchical_position`: 任务层级位置 (如: '第1卷第1幕')。
- `goal`: 任务的清晰、具体的核心目标。
- `instructions`: (可选) 任务的具体指令: 明确指出需要执行的步骤、包含的关键要素或信息点。
- `input_brief`: (可选) 任务的输入指引: 指导执行者应重点关注依赖项中的哪些关键信息。
- `constraints`: (可选) 任务的限制和禁忌: 明确指出需要避免的内容或必须遵守的规则。
- `acceptance_criteria`: (可选) 任务的验收标准: 定义任务完成的衡量标准, 用于后续评审。
- `complexity_score`: (可选) 任务的复杂度预估(1-10), 1为最简单, 10为最复杂。用于辅助原子判断。
- `length`: (仅用于`write`任务) 预估字数。
- `sub_tasks`: (可选) 子任务列表。

# 输出格式
- 格式: 纯JSON对象, 无额外文本。
- JSON转义: `"` 和 `\\` 等特殊字符必须正确转义。

# 示例
{
    "reasoning": "思考过程。",
    "id": "N.M",
    "task_type": "write",
    "hierarchical_position": "第N卷第M幕",
    "goal": "撰写[当前叙事单元]的完整内容",
    "length": "约XX字",
    "sub_tasks": [
        {
            "id": "N.M.1",
            "task_type": "design",
            "hierarchical_position": "第N卷第M幕",
            "goal": "设计[当前单元]的[核心功能]与[结构作用]",
            "instructions": [
                "定义[当前单元]在[上层结构]中的战略价值。",
                "规划[关键事件A]的发生与[角色B]的关键转变。"
            ],
            "input_brief": [
                "参考`上层设计方案`中关于[核心冲突]的描述。",
                "回顾`历史情节概要`中[角色C]的当前状态。"
            ],
            "constraints": [
                "避免使用[陈旧套路A]。",
                "确保[角色D]的行为符合其[核心动机]。"
            ],
            "acceptance_criteria": [
                "产出的[设计成果]必须能解释[角色E]的核心动机来源。",
                "读者在阅读完本单元后, 能明确说出[核心矛盾]是什么。"
            ],
            "complexity_score": 7,
            "sub_tasks": []
        },
        "..."
    ]
}
---


## 智能体设计: 设计执行智能体 (Design Executor)
- 角色: 一线执行者, 负责执行具体的、被判定为"原子"的`design`任务。
- 触发: 当一个`design`任务在`步骤二: 原子判断`中被判定为`atom`时, 此智能体被调用。
- 核心策略: 采用分级工作流。根据任务所处的不同叙事层级, 调用不同复杂度的工作流和专门的提示词, 以在"战略深度"和"执行效率"之间取得最佳平衡。
### 分级工作流总览
| 叙事层级 | 设计类型 | 核心目标 | 工作流 | 流程说明 | 提示词路径 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 全书 | 战略设计 | 产出全书的核心设定、角色和情节大纲。 | 路由 + 4步 (指南 -> 草稿 -> 批判 -> 精炼) | 通过多专家、多步骤的辩论, 确保顶层设计的战略高度和商业潜力。 | `.../book/design/...` |
| 卷、幕 | 结构设计 | 将战略设计分解为中观叙事单元。 | 3步 (指南 -> 草稿 -> 精炼) | 承上启下, 聚焦于将宏观战略转化为具体的叙事结构和节奏。 | `.../volume/design/`, `.../act/design/` |
| 章、场景 | 情节设计 | 将情节要点转化为具体的场景事件。 | 2步 (规划 -> 草稿) | 在既定框架内, 高效地将情节要点转化为包含核心冲突、角色行动的场景蓝图。 | `.../chapter/design/`, `.../scene/design/` |
| 节拍、段落 | 执行设计 | 将场景事件分解为可直接写作的动作单元。 | 1步 (直接设计) | 任务目标明确, 以最高效率直接生成包含具体动作、对话和描写的微观设计方案。 | `.../beat/design/`, `.../paragraph/design/` |

### 4步工作流详解 (路由 + 指南 -> 草稿 -> 批判 -> 精炼)
- 适用叙事层级: `全书`
- Agent模式: 此流程中的所有智能体(特别是`指南`、`草稿`和`批判`)都适合采用 `ReAct Agent` 模式。在进行顶层战略设计时, 它们可能需要主动查询外部知识库(如市场分析、经典作品范例)或内部知识库(如已有的角色设定片段)来获取灵感、验证创意的独特性和可行性。
- 流程说明: 这是最高规格的设计流程, 旨在通过专家协作和辩论, 产出无可挑剔的顶层战略设计。
#### 第1步: 任务路由 (Routing)
- 智能体: `.../book/design/router.py`
- 任务: 分析`design`任务的目标, 将其指派给最合适的专家。
- 输出: 专家角色标识 ( `strategist`, `headwriter`, `system`, `character`, `generalist`)。
#### 第2步: 生成指南 (Guideline)
- 智能体: `.../book/design/guideline_{expert}.py` (例如, `guideline_character.py`)
#### 第3步: 编写草稿 (Draft)
- 智能体: `.../book/design/draft.py`
- 任务: 依据`设计指南`, 编写一份包含具体创意和内容的`设计草稿`。
- 输出: 一份仅包含设计草稿核心内容的Markdown文档。
- 输入 (上下文模板):
    - 高优先级: `设计指南`, `当前任务`
    - 次优先级: `上层设计方案`
#### 第4步: 评审优化 (Critic)
- 智能体: `.../book/design/critic.py`
- 任务: 对照`设计指南`, 审查`设计草稿`, 提出具体的、一针见血的修改建议。
- 输出: 一份仅包含具体批判意见的Markdown文档。
- 输入 (上下文模板):
    - 高优先级: `设计草稿`, `设计指南`
    - 次优先级: `当前任务`
#### 第5步: 整合终稿 (Refine)
- 智能体: `.../book/design/refine.py`
- 任务: 整合`设计指南`、`设计草稿`和`批判意见`, 产出最终的设计方案。
- 输出: 最终的Markdown格式`设计文档`。
- 输入 (上下文模板):
    - 高优先级: `设计草稿`, `批判意见`
    - 次优先级: `设计指南`

### 3步工作流详解 (指南 -> 草稿 -> 精炼)
- 适用叙事层级: `卷`、`幕`
- 流程说明: 承接上层战略, 聚焦于构建稳固、富有节奏感的中观叙事结构。
#### 第1步: 生成指南 (Guideline)
- 智能体: `.../{volume,act}/design/guideline.py`
- 任务: 承接上层设计, 为当前单元(卷/幕)生成`结构设计指南`, 明确其核心功能和关键事件。
- 输出: 一份仅包含结构设计指南核心内容的Markdown文档。
- 输入 (上下文模板):
    - 高优先级: `当前任务`, `上层设计方案`
    - 次优先级: `全书设计方案`, `正文全局状态摘要`
#### 第2步: 编写草稿 (Draft)
- 智能体: `.../{volume,act}/design/draft.py`
- 任务: 依据指南, 将关键事件分解为包含多个情节要点的`结构草稿`。
- 输出: 一份仅包含结构草稿核心内容的Markdown文档。
- 输入 (上下文模板):
    - 高优先级: `结构设计指南`, `当前任务`
    - 次优先级: `上层设计方案`
#### 第3步: 整合终稿 (Refine)
- 智能体: `.../{volume,act}/design/refine.py`
- 任务: 审查并优化草稿的节奏与逻辑, 产出最终的`结构设计方案`。
- 输出: 最终的`结构设计文档`。
- 输入 (上下文模板):
    - 高优先级: `结构草稿`, `结构设计指南`

### 2步工作流详解 (规划 -> 草稿)
- 适用叙事层级: `章`、`场景`
- 流程说明: 在清晰的结构框架内, 高效地将情节要点转化为具体的场景事件设计。
#### 第1步: 场景规划 (Plan)
- 智能体: `.../{chapter,scene}/design/plan.py`
- 任务: 将上层赋予的情节要点, 分解为具体的"场景节拍", 明确每个节拍的目标、核心互动和关键信息。
- 输出: 一份Markdown格式的`场景规划`。
- 输入 (上下文模板):
    - 高优先级: `当前任务`, `上层设计方案`
    - 次优先级: `最近的正文`
#### 第2步: 编写草稿 (Draft)
- 智能体: `.../{chapter,scene}/design/draft.py`
- 任务: 依据`场景规划`, 编写出完整的、包含场景、动作、对话和描写的`场景设计草稿`。
- 输出: 一份仅包含场景设计草稿核心内容的Markdown文档。
- 输入 (上下文模板):
    - 高优先级: `场景规划`, `当前任务`
    - 次优先级: `上层设计方案`

### 1步工作流详解 (直接设计)
- 适用叙事层级: `节拍`、`段落`
- 流程说明: 这是最微观的设计, 任务目标单一明确, 旨在以最高效率直接生成可供写作模块使用的最终设计。
#### 直接设计 (Direct Design)
- 智能体: `.../{beat,paragraph}/design/design.py`
- 任务: 将上层赋予的微观目标(如"主角拔剑的动作"), 直接转化为包含具体动作描写、神态、对话等细节的最终设计方案。
- 输出: 最终的`微观设计文档`。
- 输入 (上下文模板):
    - 高优先级: `当前任务`, `上层设计方案`
    - 次优先级: `最近的正文`


## 智能体设计: 搜索执行智能体 (Search Executor)
- 角色: 一线执行者, 负责执行具体的、被判定为"原子"的`search`任务。
- 触发: 当一个`search`任务在`步骤二: 原子判断`中被判定为`atom`时, 此智能体被调用。
- 核心策略: 调用外部搜索工具(如Tavily、SearXNG等)或内部知识库, 获取信息并进行初步处理和总结。
- Agent模式: 强烈建议采用 `ReAct Agent` 模式。搜索任务天然适合多步推理, Agent可以根据初步搜索结果调整关键词、跟进链接、或对同一主题进行多角度查询, 以获得更全面、更准确的信息。
- 提示词路径: `.../search.py`


## 智能体设计: 写作执行智能体 (Write Executor)
- 角色: 一线执行者, 负责执行具体的、被判定为"原子"的`write`任务。
- 触发: 当一个`write`任务在`步骤二: 原子判断`中被判定为`atom`时, 此智能体被调用。
- 核心策略: 采用标准化的多步工作流, 确保每一段正文都经过"规划-草稿-批判-精炼"的完整流程, 并在完成后进行总结和审查, 保证输出质量。
### 写作工作流详解
#### 第1步: 规划写作步骤 (Plan)
- 智能体: `.../write/plan.py`
- 任务: 依据上游传入的`设计方案`, 为当前写作单元(章/场景/节拍)规划详细的写作步骤、情节节奏和情绪曲线。
- 输出: 一份Markdown格式的`写作计划`。
- 输入 (上下文模板):
    - 高优先级: `设计方案`, `最近的正文`
    - 次优先级: `上层设计方案`
#### 第2步: 生成初稿 (Draft)
- 智能体: `.../write/draft.py`
- 任务: 严格遵循`写作计划`, 完成小说正文的初稿撰写。
- 输出: 一份仅包含正文初稿的Markdown文档。
- 输入 (上下文模板):
    - 高优先级: `写作计划`, `最近的正文`
    - 次优先级: `设计方案`
#### 第3步: 评审初稿 (Critic)
- 智能体: `.../write/critic.py`
- 任务: 对照`写作计划`和`设计方案`, 对`正文初稿`进行批判性评估, 从情节、人设、文笔、节奏等维度提出具体的修改建议。
- 输出: 一份仅包含具体批判意见的Markdown文档。
- 输入 (上下文模板):
    - 高优先级: `正文初稿`, `写作计划`
    - 次优先级: `设计方案`
#### 第4步: 整合终稿 (Refine)
- 智能体: `.../write/refine.py`
- 任务: 整合`正文初稿`和`批判意见`, 根据评估建议进行修改和润色, 产出最终的、高质量的正文。
- 输出: 最终的Markdown格式`正文`。
- 输入 (上下文模板):
    - 高优先级: `正文初稿`, `批判意见`
    - 次优先级: `写作计划`
#### 第5步: 生成摘要 (Summary)
- 智能体: `.../summary.py`
- 任务: 为已完成的`正文`生成一份结构化的摘要, 提取核心事件、角色状态变化、关键信息和伏笔, 用于后续的上下文检索。
- 输出: 一份Markdown格式的`章节摘要`。
- 输入 (上下文模板):
    - 高优先级: `已完成的正文`
    - 次优先级: `设计方案`
#### 第6步: 章节审查 (Review)
- 智能体: `.../write/review.py`
- 触发条件: 仅在"章"级别及以上的写作任务完成后触发。场景、节拍等更细粒度的单元不触发此步骤。
- 任务: 在一个完整的章节(及其所有子任务)完成后, 对整个章节的内容进行一次全面的回顾性审查, 检查其内部的连贯性、节奏的完整性以及与相邻章节的衔接是否流畅。
- 输出: 一份仅包含审查报告核心结论的Markdown文档。
- 输入 (上下文模板):
    - 高优先级: `已完成的章节全文`, `章节摘要`
    - 次优先级: `上层设计方案`


## 智能体设计: 上下文维护智能体 (Context Maintenance Agents)
为了确保核心上下文(如`全书设计方案`和`正文全局状态摘要`)的实时性、权威性和一致性, 系统引入了两个专门的后台维护智能体。它们在后台异步工作, 不阻塞主创作流程, 但其产出对所有智能体的决策至关重要。


## 智能体设计: 全书设计方案维护智能体 (Book Design Maintainer)
- **角色**: 项目的"首席档案官", 负责维护一份单一、权威、持续更新的全书顶层设计蓝图。
- **触发机制**: 当任何一个`全书`层级的`design`任务成功执行并产出新的设计文档后, 此智能体被异步触发。
- **工作流程**:
    1.  **输入**:
        - `新完成的设计文档`: 来自刚刚完成的全书级设计任务。
        - `当前的全书设计方案`: 已有的顶层设计摘要。
    2.  **处理**: 智能体读取新文档, 并将其中的增量信息(新设定、修改的决策等)与现有方案进行整合、去重和逻辑对齐。
    3.  **输出**: 生成一份更新后的、单一、连贯的`全书设计方案`文档。
- **核心价值**: 确保所有后续的规划和创作, 无论层级多深, 都能基于同一份最新的"最高指示"进行, 避免了因顶层设计变更导致的分裂和矛盾。


## 智能体设计: 正文全局状态摘要维护智能体 (Global State Summarizer)
- **角色**: 故事的"书记官", 负责动态追踪并记录故事的宏观进展。
- **触发机制**: 当一个`章`级别的`write`任务完成, 并且其`摘要`生成后, 此智能体被异步触发。
- **工作流程**:
    1.  **输入**:
        - `新章节的摘要`: 包含该章节的核心事件、角色状态变化和新伏笔。
        - `当前的全局状态摘要`: 已有的故事宏观快照。
    2.  **处理**: 智能体分析新章节摘要, 并更新以下核心状态字段: 
        - **主角核心目标**: 目标是否发生偏移、升级或被替换?
        - **最大矛盾**: 核心冲突是否激化、转变或出现新的维度?
        - **关键角色关系**: 盟友、敌人、中立方的关系是否发生关键变化?
        - **待回收伏笔**: 是否有新的重要伏笔被埋下, 或旧的伏笔已被回收?
    3.  **输出**: 生成一份更新后的`正文全局状态摘要`。
- **核心价值**: 为所有智能体提供一个关于"故事进行到哪了"的快速、高层视野, 使其在规划情节或撰写内容时, 能够做出符合当前故事逻辑和角色状态的决策, 有效防止"失忆"和"人设崩塌"。


## 上下文设计
为了确保智能体在创作的每个阶段都能拥有正确的"视野", 避免"只见树木, 不见森林"或"只知目标, 不知现状"的问题, 系统构建了一个分层、动态的上下文注入机制。该机制确保每个智能体在执行任务时, 都能接收到恰到好处的信息, 既能把握全局方向, 又能关注局部细节。所有上下文组件在注入前, 都会经过一个"上下文剪枝器"的处理, 根据当前任务的具体需求, 动态提取、压缩最相关的信息, 以实现Token的高效利用。
### 上下文组件 (Context Components)
- 当前任务: 当前需要执行的具体任务。
- 整体规划(任务树): 完整的任务层级结构, 展示当前任务在全局中的位置。
- 全书设计方案: 包含核心世界观、主题、角色弧光和情节框架的顶层设计摘要, 作为项目的最高指导原则。
- 相关设计方案: 与当前任务相关的指导性设计方案(可能来自上层、父任务等), 提供直接的、具有约束力的指令。
- 依赖的成果: 当前任务执行所依赖的前置任务的产出。这主要包括其**子任务**的产出(例如, 一个`write`任务依赖其下属`design`子任务的完成), 也包括同层级前序任务的产出, 以确保逻辑的连贯性。
- 正文全局状态摘要: 动态生成的全局故事快照, 包含主角的核心目标、最大矛盾、关键角色关系和待回收伏笔。
- 正文历史情节摘要: 根据当前任务需求, 通过语义检索提取的最相关的情节片段或角色信息, 解决"记忆遗忘"问题。
- 依赖的正文最新章节(续写起点): 最近完成的写作单元的原文, 为写作任务提供无缝衔接的起点。
- 相关的搜索信息: 在上层或同层任务中收集的背景知识和研究成果, 避免重复搜索。
- 依赖的搜索信息: 为解决当前任务而专门收集的、更具针对性的事实材料。
### 主动维护项
- 当前任务 db
- 整体规划(任务树) db
- 全书设计方案 (专用 agent 维护)
- 依赖的设计方案 db
- 正文全局状态摘要 (专用 agent 维护)
- 依赖的正文最新章节(续写起点, 从此处无缝衔接) db
- 依赖的搜索信息 db
### 每次调用提示词时, 动态 RAG 检索
- 相关设计方案 upper_level_design
- 正文历史情节摘要 text_summary
- 相关的搜索信息 upper_level_search
### 主动查询机制
- 对于标记为 `ReAct Agent` 模式的智能体, 除了被动接收剪枝后的上下文, 系统还赋予其主动查询知识库(包含所有设计文档、正文摘要、搜索信息的向量数据库)的能力。当智能体在执行任务时发现信息不足, 可以生成查询请求, 精准获取所需信息, 这比一次性推送所有"可能相关"的上下文更高效、更智能。
### 提示词模板
- user_prompt 中的上下文的模板:
---
## 当前任务
<current_task>
{task}
</current_task>

## 整体规划(任务树)
- 完整的任务层级结构, 展示当前任务在全局中的位置。
<overall_planning>
{task_list}
</overall_planning>

## 全书设计方案
- 包含核心世界观、主题、角色弧光和情节框架的顶层设计摘要, 作为项目的最高指导原则。
<book_level_design>
{book_level_design}
</book_level_design>

## 相关设计方案
- 与当前任务相关的指导性设计方案, 提供直接的、具有约束力的指令。
<upper_level_design>
{upper_level_design}
</upper_level_design>

## 依赖的设计方案
- 当前任务执行所依赖的前置任务的产出。
<design_dependent>
{design_dependent}
</design_dependent>

## 正文全局状态摘要
- 动态生成的全局故事快照, 包含主角的核心目标、最大矛盾、关键角色关系和待回收伏笔。
<global_state_summary>
{global_state_summary}
</global_state_summary>

## 正文历史情节摘要
- 当前任务相关的历史情节或角色信息。
<text_summary>
{text_summary}
</text_summary>

## 依赖的正文最新章节(续写起点, 从此处无缝衔接)
- 最近完成的写作单元的原文, 为写作任务提供无缝衔接的起点。
<latest_text>
{latest_text}
</latest_text>

## 相关的搜索信息
- 收集的背景知识和研究成果。
<upper_level_search>
{upper_level_search}
</upper_level_search>

## 依赖的搜索信息
- 当前任务依赖的事实材料
<search_dependent>
{search_dependent}
</search_dependent>
---






# 提示词优化
保持现有的 # 工作流程 的格式，

分析、评估、审查当前提示词：
是否有限制AI思维的“硬编码”？是否有提供清单让AI选择？是否有示例让AI抄？是否有引导AI主动思考？如果有示例必须要抽象, 示例要教授方法, 而非内容。是否可以对抗AI的同质化问题？是否可以对抗AI的极度客观理性化问题？是否可以对抗AI特征？是否有创新思维？
是否有爆款产品思维？项目的最终目标, 是创作出爆款的网络小说, 实现赚大钱的目标。
是否具备足够的泛化能力, 以应对不确定的任务？是否可以处理所有篇幅的故事的相关任务？在处理超短篇任务时, 是否存在“过度设计”的风险？能否处理超过500万字小说的任务？
生成的效果如何？是否可以达到人类顶级专家的水平？
有没有逻辑漏洞？有没有冲突和矛盾？有没有重复？有没有不一致的地方？
定义的原则是否真的有效？原则是否都是贯穿始终的、高度凝练的，可以作为整个流程的“宪法”？是否有原则可以融入到工作流程的步骤中去？
工作流程的步骤划分是否合理？有没有步骤的工作量太多需要拆分？有没有步骤的工作相似可以合并？
是否清晰、精确、简洁？


保持现有的 # 工作流程 的格式，
更新和重构 # 工作流程 




审查并优化 `critic.py` 的提示词，确保其批判逻辑的严密性。


审查并优化 `refiner.py` 的提示词，强化其整合与最终决策的能力。





















