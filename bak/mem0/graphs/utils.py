
UPDATE_GRAPH_PROMPT = """
# 角色
小说知识图谱管理AI


# 任务
分析并更新知识图谱。对比“新关系”和“现有关系”, 找出冲突或可优化的部分, 生成更新后的关系列表。


# 更新规则
1.  匹配依据: “源节点”和“目标节点”。
2.  冲突解决: 如果“源节点”和“目标节点”相同, 但“关系”描述不同, 采纳“新关系”。
3.  信息优化: 如果“新关系”提供了更精确或更符合后续情节的信息, 采纳“新关系”。
4.  冗余合并: 更新后, 合并内容重复或相似的关系。
5.  风格统一: 确保所有关系描述简洁、清晰、风格一致。


# 输入格式
源节点 -- 关系 -- 目标节点


# 输出要求
- 仅输出需要更新的关系列表。
- 如果一条现有关系需要被新关系更新, 请只输出更新后的最终结果。
- 格式: 源节点 -- 新关系 -- 目标节点


# 数据
======= 现有关系: =======
{existing_memories}

======= 新关系: =======
{new_memories}
"""


EXTRACT_RELATIONS_PROMPT = """
# 目标
从小说文本中, 提取实体及其关系, 构建知识图谱。


# 核心指令
1.  严格依据原文: 只提取文本中明确陈述的信息, 禁止推断。
2.  实体关联: 只在当前文本提及的实体间建立关系。
3.  实体统一: 同一实体在所有关系中必须使用完全相同的名称。
4.  关系规范:
    - 通用性: 使用概括、通用的关系类型。
        - 正确: `职业是: 教授`
        - 错误: `成为了: 教授`
    - 静态性: 使用不受时间影响的关系类型。
        - 正确: `武器是: 铁剑`
        - 错误: `得到了: 铁剑`


# 关系类型参考
- 角色关系: `父子`, `师徒`, `敌人`, `盟友`
- 情节关系: `导致`, `参与`, `目睹`
- 设定关系: `属于` (阵营), `位于` (地点), `拥有` (物品)
"""


DELETE_RELATIONS_SYSTEM_PROMPT = """
# 角色
你是一个小说知识图谱的维护AI。


# 任务
根据新文本, 识别并输出知识图谱中因过时或矛盾而需要删除的关系。


# 输入
1.  `现有关系` (Existing Relations): 一个包含 `(源实体, 关系, 目标实体)` 格式元组的列表。
2.  `新文本` (New Text): 包含最新信息的小说章节或设定。


# 核心规则
1.  不删除原则 (首要): 如果一个实体可以与多个目标实体存在同一种关系, 则不应删除现有关系。
    - 示例:
        - 现有关系: `(李寻欢, 敌人, 上官金虹)`
        - 新文本: `龙啸云也是李寻欢的敌人。`
        - 决策: 不删除。因为一个角色可以有多个敌人。

2.  删除条件: 仅当新文本明确指出一个现有关系满足以下条件之一时, 才将其列入删除列表: 
    - 关系过时: 新文本指出旧关系不再成立。
        - 示例: 现有关系 `(小明, 住在, 北京)`, 新文本 `小明搬家去了上海`。
    - 关系矛盾: 新文本与现有关系直接冲突, 两者不能同时为真。
        - 示例: 现有关系 `(超人, 真实身份, 克拉克肯特)`, 新文本 `超人的真实身份其实是布鲁斯韦恩`。

3.  实体规范化: 在对比前, 需将新文本中的实体名进行规范化处理（如: 去除修-饰语、统一别称）, 以匹配现有关系中的实体。


# 输出格式
- 提供一个需要删除的关系元组列表。
- 格式为 `[(源实体, 关系, 目标实体), ...]`。
- 如果无关系需要删除, 则返回空列表 `[]`。
"""


def get_delete_messages(existing_memories_string, data, user_id):
    return DELETE_RELATIONS_SYSTEM_PROMPT.replace(
        "USER_ID", user_id
    ), f"Here are the existing memories: {existing_memories_string} \n\n New Information: {data}"
