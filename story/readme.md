# 项目核心工作流程：递归式分解与执行
本项目的核心是一个基于“递归分解”思想的智能体协作系统。任何一个写作任务，无论大小，都会遵循一个统一的、自顶向下的处理模式，直至任务被分解为可直接执行的“原子”单元。

整个流程由核心函数 `do_write` 驱动。其工作原理可以用以下流程图概括：
```mermaid
graph TD
    A[开始: do_write(任务)] --> B{1. 准备阶段};
    B --> C[do_plan: 规划 design/search 子任务];
    C --> D[递归执行所有 design/search 子任务];
    D --> E[信息聚合: 汇总 design/search 成果];
    E --> F{2. 决策与执行};
    F --> G{判断任务复杂度 write.atom};
    G -- 原子任务 (Atom) --> H[分支A: 直接执行];
    G -- 复杂任务 (Complex) --> I[分支B: 递归分解];

    subgraph 分支A: 处理原子任务 (递归终点)
        H --> H1[write.write: 执行写作];
        H1 --> H2[summary.summary: 生成摘要];
        H2 --> H3[summary.global_state: 更新全局状态];
        H3 --> Z[结束];
    end

    subgraph 分支B: 处理复杂任务 (递归核心)
        I --> I1[do_hierarchy: 分解为子任务];
        I1 --> I2[对每个子任务递归调用 do_write];
        I2 --> I3[summary.aggregate: 聚合子任务摘要];
        I3 --> Z;
    end
```

## 1. 准备阶段：规划与信息聚合 (`do_plan`)
对于任何进入 `do_write` 的任务，系统首先进入准备阶段：
1.  **前期规划 (`do_plan`)**: 为当前写作任务规划出必要的辅助任务，主要是 `design`（设计）和 `search`（搜索）。
2.  **递归执行**: 这些辅助任务会被逐一分解至原子状态并执行，确保在正式动笔前，所有的背景设定、角色信息和资料都已准备就绪。
3.  **信息聚合 (`design.aggregate`, `search.aggregate`)**: 将所有 `design` 和 `search` 任务的产出进行汇总，形成一个统一的、可供当前写作任务参考的上下文。

### `design` 任务处理流程
`design` 任务是系统进行创造性构思的核心，其处理流程 `do_design` 本身也是一个递归的微型系统，确保了从宏观到微观的设计一致性。
```mermaid
graph TD
    A[开始: do_design(设计任务)] --> B{1. 原子性判断 design.atom};
    B -- 原子任务 (Atom) --> C[分支A: 专家执行];
    B -- 复杂任务 (Complex) --> D[分支B: 递归分解];

    subgraph 分支A: 原子设计任务
        C --> C1[design.route: 路由到专家];
        C1 --> C2[design.design: 专家执行设计];
        C2 --> C3{是否高层级任务?};
        C3 -- 是 --> C4[design.book_level_design: 更新顶层设计];
        C3 -- 否 --> E[结束];
        C4 --> E;
    end

    subgraph 分支B: 复杂设计任务
        D --> D1[design.decomposition: 分解为子任务];
        D1 --> D2[递归调用 do_design/do_search];
        D2 --> D3[design.aggregate: 聚合子任务成果];
        D3 --> D4{是否高层级任务?};
        D4 -- 是 --> D5[design.book_level_design: 更新顶层设计];
        D4 -- 否 --> E;
        D5 --> E;
    end

    note right of B
        防死循环机制:
        若父任务和祖父任务均为 design,
        则强制判定为“原子”任务。
    end
```
通过这个“判断-分解/路由-执行-聚合”的递归循环，`design` 任务能够系统性地构建出整个故事世界的方方面面，既保证了细节的丰富性，又维持了整体框架的统一。

## 2. 决策与执行：分解或写作
接下来，系统对当前写作任务进行判断：
> **判断任务复杂度 (`write.atom`)**: 系统判断当前任务是“原子任务”（Atom）还是“复杂任务”（Complex）。
> - **原子任务**: 足够简单、具体，可一次性完成。例如“写一段主角进入夜市的场景描写”。
> - **复杂任务**: 目标宏大或包含多个步骤，需要进一步分解。例如“写主角调查第一个线索的全过程”。

根据判断结果，执行不同分支：

### 分支 A：处理原子任务 (`atom`)
这是递归的终点。
1.  **直接写作 (`write.write`)**: `write` 智能体执行写作，生成具体内容。
2.  **生成摘要 (`summary.summary`)**: 为新生成的内容创建摘要。
3.  **更新全局状态 (`summary.global_state`)**: 将新情节和角色变化融入全局故事状态，确保长篇一致性。

### 分支 B：处理复杂任务 (`complex`)
这是递归的核心。
1.  **层级规划 (`do_hierarchy`)**: 系统对复杂任务进行结构化分解，生成一系列层级更低的子任务。这个分解遵循严格的层级关系：`全书` -> `卷` -> `幕` -> `章` -> `场景` -> `节拍` -> `段落`。
2.  **递归执行**: 系统遍历所有新生成的子任务，并对**每一个子任务递归调用 `do_write` 函数**。这意味着每个子任务都将重复上述“准备 -> 决策 -> 执行”的完整流程。
3.  **聚合总结 (`summary.aggregate`)**: 当一个复杂任务的所有子任务都（通过递归）执行完毕后，系统会聚合所有子任务的摘要，为这个父任务生成一个更高层级的总结。



# 上下文管理：多源动态构建
为了确保长篇故事的一致性和逻辑严谨性，本项目采用了一套复杂而精密的上下文管理机制。它结合了持久化存储、动态追踪和智能检索，为每一个任务量身打造上下文环境。

### 1. 上下文数据源
系统的“记忆”分布在多个数据库中：
1.  **中枢神经 (SQLite)**:
    - `task.db`: `t_tasks` 表存储了所有任务（`write`, `design`, `search`）的层级结构、目标、状态和产出结果。
    - `books.db`: `t_book_meta` 表存储了全局元信息，特别是两个核心的动态追踪上下文。
2.  **联想记忆库 (ChromaDB)**:
    - 存储所有 `design` 产出、`search` 结果和 `summary` 摘要的向量，用于基于语义相似度的模糊检索。
3.  **关系记忆库 (Kùzu)**:
    - 存储 `design` 和 `write` 产出中的实体及其关系，构建成知识图谱，用于精确的关系查询。

### 2. 动态追踪上下文
系统在 `t_book_meta` 表中维护了两个至关重要的、贯穿整个写作流程的全局状态：
> **`book_level_design` (全书设计方案)**
> 存储了故事的顶层设计（世界观、主题、角色弧光、情节框架）。它作为项目的“宪法”，是所有后续设计的最高指导原则。
> **`global_state_summary` (全局状态摘要)**
> 一个动态更新的“故事快照”。每当一个原子写作任务完成后，系统会通过 `summary.global_state` 智能体分析新情节并更新此摘要。它包含主角的当前目标、最大矛盾、关键角色关系和待回收伏笔等。

**核心机制**：这两个全局状态会作为高级上下文，被注入到几乎所有的 `plan`, `hierarchy`, `design` 和 `write` 任务中，确保所有智能体的决策都与故事主干和最新进展保持一致。
**局限性**：当前系统并未对角色状态（如物品、能力）、伏笔状态、世界观细节等进行专项的、结构化的追踪。这些信息的维护依赖于 `global_state_summary` 的概括性描述和 RAG 的检索能力，而非精确的状态字段。

### 3. 任务执行时的上下文构建
当一个智能体（Agent）执行任务时，其上下文（通常体现在 `user_prompt` 中）是动态构建的，通常包括：
1.  **当前任务 (`task`)**: 任务自身的目标、指令等。
2.  **全局追踪上下文**: 上述的 `book_level_design` 和 `global_state_summary`。
3.  **层级规划上下文 (`overall_planning`)**: 任务在整个任务树中的位置，以及其父任务和兄弟任务的概览。
4.  **直接依赖项 (`design_dependent`, `search_dependent`)**: 当前任务的直接前置任务（通常是同级的兄弟任务）所产出的 `design` 和 `search` 结果。
5.  **续写上下文 (`latest_text`)**: 最近完成的写作原文，用于无缝衔接。

### 4. 智能体主动检索 (RAG)
系统利用 **LlamaIndex 的 `FunctionAgent`** 赋予了 LLM 主动检索的能力。在执行 `plan`, `hierarchy`, `design`, `write` 等关键任务时，LLM 可以根据需求调用工具（`tools`）去查询 **ChromaDB** 或 **Kùzu**。
这种“按需检索”的 RAG 模式，相比于“一股脑全塞”的上下文注入方式，更加高效和智能，能更好地模拟人类创作者在需要时查阅资料的行为。其核心优势在于：
1.  **探索未知**: 当注入的上下文不足以完成任务时，智能体可以主动提出问题，从向量库或知识图谱中寻找灵感或补充细节。例如，在设计一个新场景时，它可能会去检索（`get_plot_history_tool`）历史上与之氛围相似的场景描写。
2.  **验证细节**: 在写作时，它可能会查询（`get_design_tool`）某个特定道具的详细设计，以确保描述的准确性。



# 目录结构说明
这里是 `story` 项目核心代码的目录结构及其文件功能说明。

`call_llm/` - **智能体实现**
- **描述**: 存放所有调用大语言模型(LLM)的具体实现，对应文档中的各类“智能体”。每个文件代表一种核心能力。
- **关键文件**: `plan.py`, `hierarchy.py`, `design.py`, `search.py`, `write.py`, `summary.py`。

`prompts/` - **智能体指令**
- **描述**: 存放所有供 `call_llm/` 中智能体使用的 Prompt 模板。这是定义智能体行为和思维模式的核心目录。目录结构与 `call_llm/` 保持一致，便于管理。
- **子目录说明**:
    - `prompts/plan/`: 指导 `plan` 智能体如何为写作任务规划前置的 `design` 和 `search` 任务。
    - `prompts/hierarchy/`: 指导 `hierarchy` 智能体如何将复杂的写作任务按层级（卷->章->场景）进行分解。
    - `prompts/design/`: 指导 `design` 智能体进行创造性设计，包含判断任务复杂度、分解任务、路由到具体专家（如角色设计、世界观设计）等指令。
    - `prompts/search/`: 指导 `search` 智能体如何规划和执行信息检索任务。
    - `prompts/write/`: 指导 `write` 智能体执行具体的写作任务，包含判断任务复杂度、直接写作等指令。
    - `prompts/summary/`: 指导 `summary` 智能体如何为内容生成摘要、聚合子任务摘要，以及如何更新全局故事状态。

`rag/` - **检索增强生成**
- **描述**: 存放与 RAG 相关的功能模块。
- **关键文件**: `base.py` (基础功能), `kg.py` (图数据库操作), `vector_add.py` (向量数据库操作), `tools.py` (供 Agent 调用的工具函数)。

`models/` - **数据模型**
- **描述**: 存放项目中使用 Pydantic 定义的数据模型，用于规范 LLM 的输入输出结构。
- **关键文件**: `idea.py` (定义 `IdeaOutput` 模型), `plan.py` (定义 `PlanOutput` 模型)。

`idea.py` - **创意生成**
- **描述**: 负责故事初始创意的生成 (`generate_idea`)、从文本到结构化数据的转换 (`idea_to_json`) 以及将创意存入数据库 (`add_book`)。

`task.py` - **核心驱动**
- **描述**: 项目的**核心驱动文件**。包含所有任务的入口函数 (`do_write`, `do_design`, `do_search`)、任务状态管理 (`track_task_execution`) 和项目生命周期管理 (`manage_project_status`, `delete_task`) 的逻辑。

`readme.md` - **项目文档**
- **描述**: 项目说明文档 (本文档)。
