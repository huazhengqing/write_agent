# Story 

## 目录文件说明
### 智能体系统 (agent/)
智能体是系统中执行具体任务的模块，每个智能体负责特定类型的任务：
- **context.py**: 负责为任务执行提供上下文信息，包括从设计库、搜索库和摘要库中检索相关信息
- **design.py**: 处理设计类任务，包括原子性判断、任务分解、路由决策、具体设计执行和结果聚合
- **hierarchy.py**: 处理层级结构规划任务，生成故事的结构化框架
- **inquiry.py**: 生成查询问题，用于获取上下文信息
- **plan.py**: 处理任务规划，将复杂任务分解为子任务
- **pruning.py**: 任务修剪，优化任务结构
- **search.py**: 处理信息搜索任务，包括原子性判断、任务分解、具体搜索执行和结果聚合
- **summary.py**: 处理总结任务，包括内容总结和全局状态维护
- **write.py**: 处理写作任务，包括原子性判断、具体写作执行和写作审查

### 提示词系统 (prompts/)
提示词是指导AI行为的核心，每个任务类型都有对应的提示词模板：
- **atom.py**: 用于判断任务是否为原子任务
- **design/**: 设计类任务的提示词，包括角色设计、系统设计、风格设计等
- **plan/**: 任务规划提示词
- **search/**: 搜索任务提示词
- **write/**: 写作任务提示词
- **route/**: 智能体路由决策提示词
- **context/**: 上下文获取提示词
- **kg/**: 知识图谱相关提示词


## 执行流程
1. **任务创建**: 从项目目标开始，创建根任务
2. **原子性判断**: 判断任务是否可以一次性完成，还是需要分解
3. **任务规划**: 对复杂任务进行分解，生成子任务列表
4. **任务执行**: 根据任务类型调用相应的智能体执行任务
   - **设计任务**: 通过路由机制分发给专门的设计师执行
   - **搜索任务**: 执行信息检索和收集
   - **写作任务**: 生成具体的文本内容
5. **结果聚合**: 将子任务结果进行整合
6. **状态更新**: 更新全局状态和记忆库
7. **递归执行**: 对子任务重复上述流程，直到所有任务完成






分析以下：
现在调用LLM时，准备上下文，有2个方法，一个是 根据当前的任务，去调用LLM生成检索问题，有了问题去向量库和知识图谱中检索，检索出结果，作为上下文，最后整合各个上下文来调用LLM。还有一个方法是对相关的信息进行压缩和枝剪，根据当前任务形成一个相关的压缩枝剪过后的结果，作为上下文来调用LLM。
还有一个策略是不管什么上下文，只给当前最相关的信息，然后调用  react agent，把 向量库和知识图谱 做为 工具给react agent，让这个agent在执行的过程中，去库中检索相关的信息，最后给出结果。

现在的项目是写作小说，小说很可能超过几百万字，有很多的设计方案和正文内容还有摘要，在调用LLM时要准备相关的上下文，目前大多是用第1个方案，先生成检索问题，去向量库和知识图谱中检索，检索出结果，作为上下文。这样做的问题就是可能信息不全。

还有2个next 的调用，没用这个方案，因为这2个调用是生成下一个任务，没有当前的任务，所以没办法去生成检索词，它只有父任务和前一个任务，前一个任务和当前任务可能并没有太多的关系，可能 是正交的维度。这2个 next ，是用react agent，来生成，但是它要求生成的结果是json结构，而 react  agent 好像有问题，是不是能直接生成这个结构，你要帮我检查一下，llama_index 的这个 react 是不是能支持最终输出 json结果。帮我分析这样的效果如何，行不行。

最后帮我分析一下这些方法的对比，枝剪的方法还没有使用。



react  agent 



