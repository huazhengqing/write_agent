# 动态层级分解模型

## 核心理念与目标
### 核心理念
动态规划, 迭代创作。摒弃一次性的静态大纲, 采用"规划 -> 判断 -> (执行 | 分解)"的持续循环。系统在每一步都进行自我评估和调整, 模拟人类创作者在写作中不断思考和修正的过程, 以激发创造力并保证过程稳定。
### 核心目标
- 提升质量上限: 通过引入批判性思维和动态调整, 创造具有独创性的内容。
- 聚焦核心任务: 每轮规划只生成少数关键任务, 避免资源浪费。
- 实现动态纠错: 执行后即时判断, 允许系统根据中间结果调整后续路径。
### 核心优势
- 高创造力: "辩论"机制与动态纠错, 激发创意。
- 流程稳定: 规则驱动的智能体确保过程可控。
- 专业化分工: 按叙事层级调用不同专家, 提升各阶段规划质量。
- 成本效益高: 即时分解策略聚焦于当前任务, 避免了对未确定性的未来投入过多沉没成本。
### 流程控制原则
- 技术实现: 项目采用 `prefect` 作为流程控制框架。
- 顺序执行: 为保证最高创作质量, 系统在处理单本书的创作流程时, 严格遵循深度优先的顺序执行模式, 杜绝任何形式的并行处理。这模拟了人类顶级专家在创作时专注、线性的思考过程。
- 无并行: 系统不允许对一本书的内部任务(如同时设计世界观和角色)进行并行处理。流程控制完全由代码逻辑驱动, 不依赖外部状态机或图数据库进行调度。
- 宏观并行: 系统的并行能力体现在可以同时启动多个独立的、完整的书籍创作流程, 但每个流程内部依然是严格串行的。


## 核心概念
### 任务类型
整个创作过程被分解为三种基础任务: 
- 设计 (Design): 规划故事的蓝图。负责世界观、情节大纲、人物设定等所有非正文的创意工作。
- 写作 (Write): 填充故事的血肉。负责产出小说正文。
- 搜索 (Search): 收集创作的素材。负责信息收集、背景研究等。
### 设计先行原则
先规划"如何设计", 再执行"设计"。在进行任何实质性设计(如构思情节)之前, 系统会先生成一个"设计任务清单"(To-Do List)。这个清单明确了要完成当前创作单元(如一章), 需要从哪些维度(如核心冲突、角色动机、场景氛围)进行思考, 确保设计的完备性。



## 目录













## 规划和分解的最终输出: Pydantic模型 PlanNode 结构
- 在提示词中增加以下内容: 
---
# JSON 字段
- `reasoning`: 思考过程。
- `id`: 父任务ID.子任务序号。根任务为"1"。
- `task_type`: 'design', 'search', 或 'write'。
- `hierarchical_position`: 任务层级位置 (如: '第1卷第1幕')。
- `goal`: 任务的清晰、具体的核心目标。
- `instructions`: (可选) 任务的具体指令: 明确指出需要执行的步骤、包含的关键要素或信息点。
- `input_brief`: (可选) 任务的输入指引: 指导执行者应重点关注依赖项中的哪些关键信息。
- `constraints`: (可选) 任务的限制和禁忌: 明确指出需要避免的内容或必须遵守的规则。
- `acceptance_criteria`: (可选) 任务的验收标准: 定义任务完成的衡量标准, 用于后续评审。
- `complexity_score`: (可选) 任务的复杂度预估(1-10), 1为最简单, 10为最复杂。用于辅助原子判断。
- `length`: (仅用于`write`任务) 预估字数。
- `sub_tasks`: (可选) 子任务列表。

# 输出格式
- 格式: 纯JSON对象, 无额外文本。
- JSON转义: `"` 和 `\\` 等特殊字符必须正确转义。

# 示例
{
    "reasoning": "思考过程。",
    "id": "N.M",
    "task_type": "write",
    "hierarchical_position": "第N卷第M幕",
    "goal": "撰写[当前叙事单元]的完整内容",
    "length": "约XX字",
    "sub_tasks": [
        {
            "id": "N.M.1",
            "task_type": "design",
            "hierarchical_position": "第N卷第M幕",
            "goal": "设计[当前单元]的[核心功能]与[结构作用]",
            "instructions": [
                "定义[当前单元]在[上层结构]中的战略价值。",
                "规划[关键事件A]的发生与[角色B]的关键转变。"
            ],
            "input_brief": [
                "参考`上层设计方案`中关于[核心冲突]的描述。",
                "回顾`历史情节概要`中[角色C]的当前状态。"
            ],
            "constraints": [
                "避免使用[陈旧套路A]。",
                "确保[角色D]的行为符合其[核心动机]。"
            ],
            "acceptance_criteria": [
                "产出的[设计成果]必须能解释[角色E]的核心动机来源。",
                "读者在阅读完本单元后, 能明确说出[核心矛盾]是什么。"
            ],
            "complexity_score": 7,
            "sub_tasks": []
        },
        "..."
    ]
}
---






## 智能体设计: 上下文维护智能体 (Context Maintenance Agents)
为了确保核心上下文(如`全书设计方案`和`正文全局状态摘要`)的实时性、权威性和一致性, 系统引入了两个专门的后台维护智能体。它们在后台异步工作, 不阻塞主创作流程, 但其产出对所有智能体的决策至关重要。





## 上下文设计
为了确保智能体在创作的每个阶段都能拥有正确的"视野", 避免"只见树木, 不见森林"或"只知目标, 不知现状"的问题, 系统构建了一个分层、动态的上下文注入机制。该机制确保每个智能体在执行任务时, 都能接收到恰到好处的信息, 既能把握全局方向, 又能关注局部细节。所有上下文组件在注入前, 都会经过一个"上下文剪枝器"的处理, 根据当前任务的具体需求, 动态提取、压缩最相关的信息, 以实现Token的高效利用。
### 上下文组件 (Context Components)
- 当前任务: 当前需要执行的具体任务。
- 整体规划(任务树): 完整的任务层级结构, 展示当前任务在全局中的位置。
- 全书设计方案: 包含核心世界观、主题、角色弧光和情节框架的顶层设计摘要, 作为项目的最高指导原则。
- 相关设计方案: 与当前任务相关的指导性设计方案(可能来自上层、父任务等), 提供直接的、具有约束力的指令。
- 依赖的成果: 当前任务执行所依赖的前置任务的产出。这主要包括其**子任务**的产出(例如, 一个`write`任务依赖其下属`design`子任务的完成), 也包括同层级前序任务的产出, 以确保逻辑的连贯性。
- 正文全局状态摘要: 动态生成的全局故事快照, 包含主角的核心目标、最大矛盾、关键角色关系和待回收伏笔。
- 正文历史情节摘要: 根据当前任务需求, 通过语义检索提取的最相关的情节片段或角色信息, 解决"记忆遗忘"问题。
- 依赖的正文最新章节(续写起点): 最近完成的写作单元的原文, 为写作任务提供无缝衔接的起点。
- 相关的搜索信息: 在上层或同层任务中收集的背景知识和研究成果, 避免重复搜索。
- 依赖的搜索信息: 为解决当前任务而专门收集的、更具针对性的事实材料。
### 主动维护项
- 当前任务 db
- 整体规划(任务树) db
- 全书设计方案 (专用 agent 维护)
- 依赖的设计方案 db
- 正文全局状态摘要 (专用 agent 维护)
- 依赖的正文最新章节(续写起点, 从此处无缝衔接) db
- 依赖的搜索信息 db
### 每次调用提示词时, 动态 RAG 检索
- 相关设计方案 upper_level_design
- 正文历史情节摘要 text_summary
- 相关的搜索信息 upper_level_search
### 主动查询机制
- 对于标记为 `ReAct Agent` 模式的智能体, 除了被动接收剪枝后的上下文, 系统还赋予其主动查询知识库(包含所有设计文档、正文摘要、搜索信息的向量数据库)的能力。当智能体在执行任务时发现信息不足, 可以生成查询请求, 精准获取所需信息, 这比一次性推送所有"可能相关"的上下文更高效、更智能。
### 提示词模板
- user_prompt 中的上下文的模板:
---
## 当前任务
<current_task>
{task}
</current_task>

## 整体规划(任务树)
- 完整的任务层级结构, 展示当前任务在全局中的位置。
<overall_planning>
{task_list}
</overall_planning>

## 全书设计方案
- 包含核心世界观、主题、角色弧光和情节框架的顶层设计摘要, 作为项目的最高指导原则。
<book_level_design>
{book_level_design}
</book_level_design>

## 相关设计方案
- 与当前任务相关的指导性设计方案, 提供直接的、具有约束力的指令。
<upper_level_design>
{upper_level_design}
</upper_level_design>

## 依赖的设计方案
- 当前任务执行所依赖的前置任务的产出。
<design_dependent>
{design_dependent}
</design_dependent>

## 正文全局状态摘要
- 动态生成的全局故事快照, 包含主角的核心目标、最大矛盾、关键角色关系和待回收伏笔。
<global_state_summary>
{global_state_summary}
</global_state_summary>

## 正文历史情节摘要
- 当前任务相关的历史情节或角色信息。
<text_summary>
{text_summary}
</text_summary>

## 依赖的正文最新章节(续写起点, 从此处无缝衔接)
- 最近完成的写作单元的原文, 为写作任务提供无缝衔接的起点。
<latest_text>
{latest_text}
</latest_text>

## 相关的搜索信息
- 收集的背景知识和研究成果。
<upper_level_search>
{upper_level_search}
</upper_level_search>

## 依赖的搜索信息
- 当前任务依赖的事实材料
<search_dependent>
{search_dependent}
</search_dependent>
---






# 提示词优化

分析、评估、审查、改进、强化当前提示词：

逻辑是否严密？有没有逻辑漏洞？有没有冲突和矛盾？输出有没有缺少要素？有没有遗漏？是否需要强化能力？

任务不限于从零设计一个完整的东西, 更可能是补充、调整、深化某个东西要素。
工作流程是否具有弹性？工作流程是否能够适应不同性质（创造、补充、调整）和规模（大、小）的任务，避免“杀鸡用牛刀”或“力不从心”？是否可以根据任务的复杂性进行裁剪或简化？
工作流程是否具备足够的泛化能力？是否能够有效支撑不同篇幅（短篇/长篇）和类型（言情/悬疑）的创作？
工作流程是否有逻辑完备性？工作流步骤是否合理、无遗漏、无冗余？有没有缺少/需要拆分/可以合并的步骤？

工作流程之外，要有原则，原则条目优先融入到工作流程中，只有贯穿始终的、高度凝练的条目才写在原则里。
定义的原则是否真的有效？原则是否都是贯穿始终的、高度凝练的, 可以作为整个流程的“宪法”？原则中是否有条目可以融入到工作流程的步骤中去？

是否可以规避AI特征？是否可以规避AI同质化、套路化、过时内容、过于工整、可预测的问题？是否可以规避AI绝对理性、绝对客观、没有情感情绪、完全没有人性化的问题？是否可以对抗AI固有的逻辑完美性？是否有引导AI主动思考？是否有创新思维？当前的创新只是对现有元素的重组，还是真正意义上的范式突破？是否有人性？是否可以达到人类顶级专家的水平？

是否有限制AI思维的“硬编码”？有没有写死的清单？是否提供了各种示例，例如？能不能不要写死？能不能不要有各种的示例、例如？能不能删除示例防止示例污染？能不能移除硬编码和示例，引导AI根据具体上下文，动态地建立自己的分析框架，从而激发更深层次、更高质量的思考？

方法论的本质：它应该是为解决当前问题而创造的根本性解法。应该是一次性的。
抽象的价值：我们要求它抽象，不是为了“复用”，而是为了抓住问题的本质，形成一个逻辑自洽的思考框架，而不是一个只能用一次的具体方案。

优化提示词，使其更加清晰、精确和简洁。

优化这段提示词，使其更加清晰、精确和简洁。


工作流程每个步骤的格式调整为更简洁的列表形式，去掉 目标 动作 这几个字




工作流程 改为 序号列表的格式，列表间都空一行








search_task_principles = """
# Search任务原则
仅当构思依赖模型通用知识之外的、必须通过外部搜索才能获取的客观事实时, 才创建`search`任务。
"""




- **任务驱动**: 所有问题都必须直接服务于`当前任务`的成功执行。
- **填补空白**: 严格专注于探询已有上下文中**未知或模糊**的信息，绝不重复提问。
- **系统思考**: 运用图谱思维，不仅关注单个设计元素，更要探询元素间的关联、结构与因果。








方案一：最简化方案 - Streamlit / Gradio (Web UI)
这是我认为最符合您“要求简单”的方案。它能以极低的成本快速搭建一个功能完善的Web UI，并且能很好地与您现有的Python代码集成。

为什么推荐它？

极简开发：你不需要懂前端。只需用Python调用它们的库，就能生成交互式组件（按钮、文本框、图表）。
完美集成：可以直接在Streamlit/Gradio脚本中导入并调用您现有的agent逻辑和数据库访问代码。无需构建复杂的API。
实时刷新：可以轻松实现定时刷新机制，轮询数据库（例如SQLite中的任务状态表），动态更新UI，展示流程进度。
强大的可视化能力：有现成的组件可以渲染Markdown、JSON、图表等。您可以用graphviz库生成任务树的SVG图像，然后在UI上显示。
实现思路：

主视图 - 任务树：

创建一个函数，该函数读取SQLite中的所有任务，根据id和sub_tasks关系构建一个图（使用graphviz或类似库）。
为每个节点根据其状态（例如，从数据库读取status字段）着色：绿色代表完成，黄色代表进行中，红色代表失败，灰色代表待处理。
在Streamlit/Gradio界面上，将生成的图显示出来。设置一个“刷新”按钮或自动刷新计时器。
侧边栏/详情区 - 任务详情：

当用户在UI上选择一个任务ID（可以通过下拉菜单或在图上点击实现），UI会从SQLite中查询该任务的完整PlanNode数据。
将PlanNode的JSON数据格式化后显示出来。
根据任务ID，进一步从ChromaDB或Kuzu中查询并展示该任务的产出（设计文档、正文片段等）。
交互功能：

在UI顶部放置一个“启动新书创作”的按钮，点击后触发您prefect流程的入口函数。
在任务详情区，为“失败”的任务添加一个“重试”按钮，点击后调用一个函数来重新执行该特定任务。

























